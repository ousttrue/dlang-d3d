// this is generated by sukonbu
import std.typecons;
import std.json;
import std.conv;
import std.algorithm;
import std.array;


float asFloat(const JSONValue value)
{
    return asFloat(&value);
}
float asFloat(const JSONValue* value)
{
    if(value.type == JSONType.float_)
    {
        return cast(float)value.floating;
    }
    else if(value.type== JSONType.integer)
    {
        return cast(float)value.integer;
    }
    else{
        throw new Exception("type error");
    }
}


enum AccessorComponentType
{
    BYTE = 5120,
    UNSIGNED_BYTE = 5121,
    SHORT = 5122,
    UNSIGNED_SHORT = 5123,
    UNSIGNED_INT = 5125,
    FLOAT = 5126,
}

enum AccessorType
{
    SCALAR = "SCALAR",
    VEC2 = "VEC2",
    VEC3 = "VEC3",
    VEC4 = "VEC4",
    MAT2 = "MAT2",
    MAT3 = "MAT3",
    MAT4 = "MAT4",
}

enum AccessorSparseIndicesComponentType
{
    UNSIGNED_BYTE = 5121,
    UNSIGNED_SHORT = 5123,
    UNSIGNED_INT = 5125,
}

class AccessorSparseIndicesExtension
{

    static AccessorSparseIndicesExtension fromJSON(JSONValue src)
    {
        auto value = new AccessorSparseIndicesExtension();
        return value;
    }
}

class AccessorSparseIndicesExtras
{

    static AccessorSparseIndicesExtras fromJSON(JSONValue src)
    {
        auto value = new AccessorSparseIndicesExtras();
        return value;
    }
}

class AccessorSparseIndices
{
    // The index of the bufferView.
    Nullable!int bufferView;
    // The offset relative to the start of the bufferView in bytes. Must be aligned.
    Nullable!int byteOffset;
    // The indices data type.
    AccessorSparseIndicesComponentType componentType;
    // Dictionary object with extension-specific objects.
    AccessorSparseIndicesExtension extensions;
    // Application-specific data.
    AccessorSparseIndicesExtras extras;

    static AccessorSparseIndices fromJSON(JSONValue src)
    {
        auto value = new AccessorSparseIndices();
        if(const(JSONValue)* x = "bufferView" in src){ value.bufferView = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "byteOffset" in src){ value.byteOffset = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "componentType" in src){ value.componentType = cast(AccessorSparseIndicesComponentType)x.integer; }
        // not implemented: AccessorSparseIndicesExtension
        // not implemented: AccessorSparseIndicesExtras
        return value;
    }
}

class AccessorSparseValuesExtension
{

    static AccessorSparseValuesExtension fromJSON(JSONValue src)
    {
        auto value = new AccessorSparseValuesExtension();
        return value;
    }
}

class AccessorSparseValuesExtras
{

    static AccessorSparseValuesExtras fromJSON(JSONValue src)
    {
        auto value = new AccessorSparseValuesExtras();
        return value;
    }
}

class AccessorSparseValues
{
    // The index of the bufferView.
    Nullable!int bufferView;
    // The offset relative to the start of the bufferView in bytes. Must be aligned.
    Nullable!int byteOffset;
    // Dictionary object with extension-specific objects.
    AccessorSparseValuesExtension extensions;
    // Application-specific data.
    AccessorSparseValuesExtras extras;

    static AccessorSparseValues fromJSON(JSONValue src)
    {
        auto value = new AccessorSparseValues();
        if(const(JSONValue)* x = "bufferView" in src){ value.bufferView = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "byteOffset" in src){ value.byteOffset = nullable(cast(int)x.integer); }
        // not implemented: AccessorSparseValuesExtension
        // not implemented: AccessorSparseValuesExtras
        return value;
    }
}

class AccessorSparseExtension
{

    static AccessorSparseExtension fromJSON(JSONValue src)
    {
        auto value = new AccessorSparseExtension();
        return value;
    }
}

class AccessorSparseExtras
{

    static AccessorSparseExtras fromJSON(JSONValue src)
    {
        auto value = new AccessorSparseExtras();
        return value;
    }
}

class AccessorSparse
{
    // Number of entries stored in the sparse array.
    Nullable!int count;
    // Indices of those attributes that deviate from their initialization value.
    AccessorSparseIndices indices;
    // Array of size `accessor.sparse.count` times number of components storing the displaced accessor attributes pointed by `accessor.sparse.indices`.
    AccessorSparseValues values;
    // Dictionary object with extension-specific objects.
    AccessorSparseExtension extensions;
    // Application-specific data.
    AccessorSparseExtras extras;

    static AccessorSparse fromJSON(JSONValue src)
    {
        auto value = new AccessorSparse();
        if(const(JSONValue)* x = "count" in src){ value.count = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "indices" in src){ value.indices = AccessorSparseIndices.fromJSON(src["indices"]); }
        if(const(JSONValue)* x = "values" in src){ value.values = AccessorSparseValues.fromJSON(src["values"]); }
        // not implemented: AccessorSparseExtension
        // not implemented: AccessorSparseExtras
        return value;
    }
}

class AccessorExtension
{

    static AccessorExtension fromJSON(JSONValue src)
    {
        auto value = new AccessorExtension();
        return value;
    }
}

class AccessorExtras
{

    static AccessorExtras fromJSON(JSONValue src)
    {
        auto value = new AccessorExtras();
        return value;
    }
}

class Accessor
{
    // The index of the bufferView.
    Nullable!int bufferView;
    // The offset relative to the start of the bufferView in bytes.
    Nullable!int byteOffset;
    // The datatype of components in the attribute.
    AccessorComponentType componentType;
    // Specifies whether integer data values should be normalized.
    Nullable!bool normalized;
    // The number of attributes referenced by this accessor.
    Nullable!int count;
    // Specifies if the attribute is a scalar, vector, or matrix.
    AccessorType type;
    // Maximum value of each component in this attribute.
    float[] max;
    // Minimum value of each component in this attribute.
    float[] min;
    // Sparse storage of attributes that deviate from their initialization value.
    AccessorSparse sparse;
    // The user-defined name of this object.
    string name;
    // Dictionary object with extension-specific objects.
    AccessorExtension extensions;
    // Application-specific data.
    AccessorExtras extras;

    static Accessor fromJSON(JSONValue src)
    {
        auto value = new Accessor();
        if(const(JSONValue)* x = "bufferView" in src){ value.bufferView = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "byteOffset" in src){ value.byteOffset = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "componentType" in src){ value.componentType = cast(AccessorComponentType)x.integer; }
        if(const(JSONValue)* x = "normalized" in src){ value.normalized = x.boolean; }
        if(const(JSONValue)* x = "count" in src){ value.count = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "type" in src){ value.type = to!AccessorType(x.str); }
        if(const(JSONValue)* x = "max" in src){ value.max = x.array.map!(a => a.asFloat).array; }
        if(const(JSONValue)* x = "min" in src){ value.min = x.array.map!(a => a.asFloat).array; }
        if(const(JSONValue)* x = "sparse" in src){ value.sparse = AccessorSparse.fromJSON(src["sparse"]); }
        if(const(JSONValue)* x = "name" in src){ value.name = x.str; }
        // not implemented: AccessorExtension
        // not implemented: AccessorExtras
        return value;
    }
}

enum AnimationChannelTargetPath
{
    translation = "translation",
    rotation = "rotation",
    scale = "scale",
    weights = "weights",
}

class AnimationChannelTargetExtension
{

    static AnimationChannelTargetExtension fromJSON(JSONValue src)
    {
        auto value = new AnimationChannelTargetExtension();
        return value;
    }
}

class AnimationChannelTargetExtras
{

    static AnimationChannelTargetExtras fromJSON(JSONValue src)
    {
        auto value = new AnimationChannelTargetExtras();
        return value;
    }
}

class AnimationChannelTarget
{
    // The index of the bufferView.
    Nullable!int node;
    // The name of the node's TRS property to modify, or the "weights" of the Morph Targets it instantiates. For the "translation" property, the values that are provided by the sampler are the translation along the x, y, and z axes. For the "rotation" property, the values are a quaternion in the order (x, y, z, w), where w is the scalar. For the "scale" property, the values are the scaling factors along the x, y, and z axes.
    AnimationChannelTargetPath path;
    // Dictionary object with extension-specific objects.
    AnimationChannelTargetExtension extensions;
    // Application-specific data.
    AnimationChannelTargetExtras extras;

    static AnimationChannelTarget fromJSON(JSONValue src)
    {
        auto value = new AnimationChannelTarget();
        if(const(JSONValue)* x = "node" in src){ value.node = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "path" in src){ value.path = to!AnimationChannelTargetPath(x.str); }
        // not implemented: AnimationChannelTargetExtension
        // not implemented: AnimationChannelTargetExtras
        return value;
    }
}

class AnimationChannelExtension
{

    static AnimationChannelExtension fromJSON(JSONValue src)
    {
        auto value = new AnimationChannelExtension();
        return value;
    }
}

class AnimationChannelExtras
{

    static AnimationChannelExtras fromJSON(JSONValue src)
    {
        auto value = new AnimationChannelExtras();
        return value;
    }
}

class AnimationChannel
{
    // The index of the bufferView.
    Nullable!int sampler;
    // The index of the node and TRS property that an animation channel targets.
    AnimationChannelTarget target;
    // Dictionary object with extension-specific objects.
    AnimationChannelExtension extensions;
    // Application-specific data.
    AnimationChannelExtras extras;

    static AnimationChannel fromJSON(JSONValue src)
    {
        auto value = new AnimationChannel();
        if(const(JSONValue)* x = "sampler" in src){ value.sampler = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "target" in src){ value.target = AnimationChannelTarget.fromJSON(src["target"]); }
        // not implemented: AnimationChannelExtension
        // not implemented: AnimationChannelExtras
        return value;
    }
}

enum AnimationSamplerInterpolation
{
    LINEAR = "LINEAR",
    STEP = "STEP",
    CUBICSPLINE = "CUBICSPLINE",
}

class AnimationSamplerExtension
{

    static AnimationSamplerExtension fromJSON(JSONValue src)
    {
        auto value = new AnimationSamplerExtension();
        return value;
    }
}

class AnimationSamplerExtras
{

    static AnimationSamplerExtras fromJSON(JSONValue src)
    {
        auto value = new AnimationSamplerExtras();
        return value;
    }
}

class AnimationSampler
{
    // The index of the bufferView.
    Nullable!int input;
    // Interpolation algorithm.
    AnimationSamplerInterpolation interpolation;
    // The index of the bufferView.
    Nullable!int output;
    // Dictionary object with extension-specific objects.
    AnimationSamplerExtension extensions;
    // Application-specific data.
    AnimationSamplerExtras extras;

    static AnimationSampler fromJSON(JSONValue src)
    {
        auto value = new AnimationSampler();
        if(const(JSONValue)* x = "input" in src){ value.input = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "interpolation" in src){ value.interpolation = to!AnimationSamplerInterpolation(x.str); }
        if(const(JSONValue)* x = "output" in src){ value.output = nullable(cast(int)x.integer); }
        // not implemented: AnimationSamplerExtension
        // not implemented: AnimationSamplerExtras
        return value;
    }
}

class AnimationExtension
{

    static AnimationExtension fromJSON(JSONValue src)
    {
        auto value = new AnimationExtension();
        return value;
    }
}

class AnimationExtras
{

    static AnimationExtras fromJSON(JSONValue src)
    {
        auto value = new AnimationExtras();
        return value;
    }
}

class Animation
{
    // An array of channels, each of which targets an animation's sampler at a node's property. Different channels of the same animation can't have equal targets.
    AnimationChannel[] channels;
    // An array of samplers that combines input and output accessors with an interpolation algorithm to define a keyframe graph (but not its target).
    AnimationSampler[] samplers;
    // The user-defined name of this object.
    string name;
    // Dictionary object with extension-specific objects.
    AnimationExtension extensions;
    // Application-specific data.
    AnimationExtras extras;

    static Animation fromJSON(JSONValue src)
    {
        auto value = new Animation();
        if(const(JSONValue)* x = "channels" in src){ value.channels = x.array.map!(a => AnimationChannel.fromJSON(a)).array; }
        if(const(JSONValue)* x = "samplers" in src){ value.samplers = x.array.map!(a => AnimationSampler.fromJSON(a)).array; }
        if(const(JSONValue)* x = "name" in src){ value.name = x.str; }
        // not implemented: AnimationExtension
        // not implemented: AnimationExtras
        return value;
    }
}

class AssetExtension
{

    static AssetExtension fromJSON(JSONValue src)
    {
        auto value = new AssetExtension();
        return value;
    }
}

class AssetExtras
{

    static AssetExtras fromJSON(JSONValue src)
    {
        auto value = new AssetExtras();
        return value;
    }
}

class Asset
{
    // A copyright message suitable for display to credit the content creator.
    string copyright;
    // Tool that generated this glTF model.  Useful for debugging.
    string generator;
    // The glTF version that this asset targets.
    string version_;
    // The minimum glTF version that this asset targets.
    string minVersion;
    // Dictionary object with extension-specific objects.
    AssetExtension extensions;
    // Application-specific data.
    AssetExtras extras;

    static Asset fromJSON(JSONValue src)
    {
        auto value = new Asset();
        if(const(JSONValue)* x = "copyright" in src){ value.copyright = x.str; }
        if(const(JSONValue)* x = "generator" in src){ value.generator = x.str; }
        if(const(JSONValue)* x = "version" in src){ value.version_ = x.str; }
        if(const(JSONValue)* x = "minVersion" in src){ value.minVersion = x.str; }
        // not implemented: AssetExtension
        // not implemented: AssetExtras
        return value;
    }
}

class BufferExtension
{

    static BufferExtension fromJSON(JSONValue src)
    {
        auto value = new BufferExtension();
        return value;
    }
}

class BufferExtras
{

    static BufferExtras fromJSON(JSONValue src)
    {
        auto value = new BufferExtras();
        return value;
    }
}

class Buffer
{
    // The uri of the buffer.
    string uri;
    // The length of the buffer in bytes.
    Nullable!int byteLength;
    // The user-defined name of this object.
    string name;
    // Dictionary object with extension-specific objects.
    BufferExtension extensions;
    // Application-specific data.
    BufferExtras extras;

    static Buffer fromJSON(JSONValue src)
    {
        auto value = new Buffer();
        if(const(JSONValue)* x = "uri" in src){ value.uri = x.str; }
        if(const(JSONValue)* x = "byteLength" in src){ value.byteLength = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "name" in src){ value.name = x.str; }
        // not implemented: BufferExtension
        // not implemented: BufferExtras
        return value;
    }
}

enum BufferViewTarget
{
    ARRAY_BUFFER = 34962,
    ELEMENT_ARRAY_BUFFER = 34963,
}

class BufferViewExtension
{

    static BufferViewExtension fromJSON(JSONValue src)
    {
        auto value = new BufferViewExtension();
        return value;
    }
}

class BufferViewExtras
{

    static BufferViewExtras fromJSON(JSONValue src)
    {
        auto value = new BufferViewExtras();
        return value;
    }
}

class BufferView
{
    // The index of the bufferView.
    Nullable!int buffer;
    // The offset into the buffer in bytes.
    Nullable!int byteOffset;
    // The total byte length of the buffer view.
    Nullable!int byteLength;
    // The stride, in bytes.
    Nullable!int byteStride;
    // The target that the GPU buffer should be bound to.
    BufferViewTarget target;
    // The user-defined name of this object.
    string name;
    // Dictionary object with extension-specific objects.
    BufferViewExtension extensions;
    // Application-specific data.
    BufferViewExtras extras;

    static BufferView fromJSON(JSONValue src)
    {
        auto value = new BufferView();
        if(const(JSONValue)* x = "buffer" in src){ value.buffer = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "byteOffset" in src){ value.byteOffset = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "byteLength" in src){ value.byteLength = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "byteStride" in src){ value.byteStride = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "target" in src){ value.target = cast(BufferViewTarget)x.integer; }
        if(const(JSONValue)* x = "name" in src){ value.name = x.str; }
        // not implemented: BufferViewExtension
        // not implemented: BufferViewExtras
        return value;
    }
}

class CameraOrthographicExtension
{

    static CameraOrthographicExtension fromJSON(JSONValue src)
    {
        auto value = new CameraOrthographicExtension();
        return value;
    }
}

class CameraOrthographicExtras
{

    static CameraOrthographicExtras fromJSON(JSONValue src)
    {
        auto value = new CameraOrthographicExtras();
        return value;
    }
}

class CameraOrthographic
{
    // The floating-point horizontal magnification of the view. Must not be zero.
    Nullable!float xmag;
    // The floating-point vertical magnification of the view. Must not be zero.
    Nullable!float ymag;
    // The floating-point distance to the far clipping plane. `zfar` must be greater than `znear`.
    Nullable!float zfar;
    // The floating-point distance to the near clipping plane.
    Nullable!float znear;
    // Dictionary object with extension-specific objects.
    CameraOrthographicExtension extensions;
    // Application-specific data.
    CameraOrthographicExtras extras;

    static CameraOrthographic fromJSON(JSONValue src)
    {
        auto value = new CameraOrthographic();
        if(const(JSONValue)* x = "xmag" in src){ value.xmag = nullable(x.asFloat); }
        if(const(JSONValue)* x = "ymag" in src){ value.ymag = nullable(x.asFloat); }
        if(const(JSONValue)* x = "zfar" in src){ value.zfar = nullable(x.asFloat); }
        if(const(JSONValue)* x = "znear" in src){ value.znear = nullable(x.asFloat); }
        // not implemented: CameraOrthographicExtension
        // not implemented: CameraOrthographicExtras
        return value;
    }
}

class CameraPerspectiveExtension
{

    static CameraPerspectiveExtension fromJSON(JSONValue src)
    {
        auto value = new CameraPerspectiveExtension();
        return value;
    }
}

class CameraPerspectiveExtras
{

    static CameraPerspectiveExtras fromJSON(JSONValue src)
    {
        auto value = new CameraPerspectiveExtras();
        return value;
    }
}

class CameraPerspective
{
    // The floating-point aspect ratio of the field of view.
    Nullable!float aspectRatio;
    // The floating-point vertical field of view in radians.
    Nullable!float yfov;
    // The floating-point distance to the far clipping plane.
    Nullable!float zfar;
    // The floating-point distance to the near clipping plane.
    Nullable!float znear;
    // Dictionary object with extension-specific objects.
    CameraPerspectiveExtension extensions;
    // Application-specific data.
    CameraPerspectiveExtras extras;

    static CameraPerspective fromJSON(JSONValue src)
    {
        auto value = new CameraPerspective();
        if(const(JSONValue)* x = "aspectRatio" in src){ value.aspectRatio = nullable(x.asFloat); }
        if(const(JSONValue)* x = "yfov" in src){ value.yfov = nullable(x.asFloat); }
        if(const(JSONValue)* x = "zfar" in src){ value.zfar = nullable(x.asFloat); }
        if(const(JSONValue)* x = "znear" in src){ value.znear = nullable(x.asFloat); }
        // not implemented: CameraPerspectiveExtension
        // not implemented: CameraPerspectiveExtras
        return value;
    }
}

enum CameraType
{
    perspective = "perspective",
    orthographic = "orthographic",
}

class CameraExtension
{

    static CameraExtension fromJSON(JSONValue src)
    {
        auto value = new CameraExtension();
        return value;
    }
}

class CameraExtras
{

    static CameraExtras fromJSON(JSONValue src)
    {
        auto value = new CameraExtras();
        return value;
    }
}

class Camera
{
    // An orthographic camera containing properties to create an orthographic projection matrix.
    CameraOrthographic orthographic;
    // A perspective camera containing properties to create a perspective projection matrix.
    CameraPerspective perspective;
    // Specifies if the camera uses a perspective or orthographic projection.
    CameraType type;
    // The user-defined name of this object.
    string name;
    // Dictionary object with extension-specific objects.
    CameraExtension extensions;
    // Application-specific data.
    CameraExtras extras;

    static Camera fromJSON(JSONValue src)
    {
        auto value = new Camera();
        if(const(JSONValue)* x = "orthographic" in src){ value.orthographic = CameraOrthographic.fromJSON(src["orthographic"]); }
        if(const(JSONValue)* x = "perspective" in src){ value.perspective = CameraPerspective.fromJSON(src["perspective"]); }
        if(const(JSONValue)* x = "type" in src){ value.type = to!CameraType(x.str); }
        if(const(JSONValue)* x = "name" in src){ value.name = x.str; }
        // not implemented: CameraExtension
        // not implemented: CameraExtras
        return value;
    }
}

enum ImageMimeType
{
    imagejpeg = "image/jpeg",
    imagepng = "image/png",
}

class ImageExtension
{

    static ImageExtension fromJSON(JSONValue src)
    {
        auto value = new ImageExtension();
        return value;
    }
}

class ImageExtras
{

    static ImageExtras fromJSON(JSONValue src)
    {
        auto value = new ImageExtras();
        return value;
    }
}

class Image
{
    // The uri of the image.
    string uri;
    // The image's MIME type. Required if `bufferView` is defined.
    ImageMimeType mimeType;
    // The index of the bufferView.
    Nullable!int bufferView;
    // The user-defined name of this object.
    string name;
    // Dictionary object with extension-specific objects.
    ImageExtension extensions;
    // Application-specific data.
    ImageExtras extras;

    static Image fromJSON(JSONValue src)
    {
        auto value = new Image();
        if(const(JSONValue)* x = "uri" in src){ value.uri = x.str; }
        if(const(JSONValue)* x = "mimeType" in src){ value.mimeType = to!ImageMimeType(x.str); }
        if(const(JSONValue)* x = "bufferView" in src){ value.bufferView = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "name" in src){ value.name = x.str; }
        // not implemented: ImageExtension
        // not implemented: ImageExtras
        return value;
    }
}

class MaterialExtension
{

    static MaterialExtension fromJSON(JSONValue src)
    {
        auto value = new MaterialExtension();
        return value;
    }
}

class MaterialExtras
{

    static MaterialExtras fromJSON(JSONValue src)
    {
        auto value = new MaterialExtras();
        return value;
    }
}

class TextureInfoExtension
{

    static TextureInfoExtension fromJSON(JSONValue src)
    {
        auto value = new TextureInfoExtension();
        return value;
    }
}

class TextureInfoExtras
{

    static TextureInfoExtras fromJSON(JSONValue src)
    {
        auto value = new TextureInfoExtras();
        return value;
    }
}

class TextureInfo
{
    // The index of the bufferView.
    Nullable!int index;
    // The set index of texture's TEXCOORD attribute used for texture coordinate mapping.
    Nullable!int texCoord;
    // Dictionary object with extension-specific objects.
    TextureInfoExtension extensions;
    // Application-specific data.
    TextureInfoExtras extras;

    static TextureInfo fromJSON(JSONValue src)
    {
        auto value = new TextureInfo();
        if(const(JSONValue)* x = "index" in src){ value.index = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "texCoord" in src){ value.texCoord = nullable(cast(int)x.integer); }
        // not implemented: TextureInfoExtension
        // not implemented: TextureInfoExtras
        return value;
    }
}

class MaterialPBRMetallicRoughnessExtension
{

    static MaterialPBRMetallicRoughnessExtension fromJSON(JSONValue src)
    {
        auto value = new MaterialPBRMetallicRoughnessExtension();
        return value;
    }
}

class MaterialPBRMetallicRoughnessExtras
{

    static MaterialPBRMetallicRoughnessExtras fromJSON(JSONValue src)
    {
        auto value = new MaterialPBRMetallicRoughnessExtras();
        return value;
    }
}

class MaterialPBRMetallicRoughness
{
    // The material's base color factor.
    float[] baseColorFactor;
    // Reference to a texture.
    TextureInfo baseColorTexture;
    // The metalness of the material.
    Nullable!float metallicFactor;
    // The roughness of the material.
    Nullable!float roughnessFactor;
    // Reference to a texture.
    TextureInfo metallicRoughnessTexture;
    // Dictionary object with extension-specific objects.
    MaterialPBRMetallicRoughnessExtension extensions;
    // Application-specific data.
    MaterialPBRMetallicRoughnessExtras extras;

    static MaterialPBRMetallicRoughness fromJSON(JSONValue src)
    {
        auto value = new MaterialPBRMetallicRoughness();
        if(const(JSONValue)* x = "baseColorFactor" in src){ value.baseColorFactor = x.array.map!(a => a.asFloat).array; }
        if(const(JSONValue)* x = "baseColorTexture" in src){ value.baseColorTexture = TextureInfo.fromJSON(src["baseColorTexture"]); }
        if(const(JSONValue)* x = "metallicFactor" in src){ value.metallicFactor = nullable(x.asFloat); }
        if(const(JSONValue)* x = "roughnessFactor" in src){ value.roughnessFactor = nullable(x.asFloat); }
        if(const(JSONValue)* x = "metallicRoughnessTexture" in src){ value.metallicRoughnessTexture = TextureInfo.fromJSON(src["metallicRoughnessTexture"]); }
        // not implemented: MaterialPBRMetallicRoughnessExtension
        // not implemented: MaterialPBRMetallicRoughnessExtras
        return value;
    }
}

class MaterialNormalTextureInfoExtension
{

    static MaterialNormalTextureInfoExtension fromJSON(JSONValue src)
    {
        auto value = new MaterialNormalTextureInfoExtension();
        return value;
    }
}

class MaterialNormalTextureInfoExtras
{

    static MaterialNormalTextureInfoExtras fromJSON(JSONValue src)
    {
        auto value = new MaterialNormalTextureInfoExtras();
        return value;
    }
}

class MaterialNormalTextureInfo
{
    // The index of the bufferView.
    Nullable!int index;
    // The set index of texture's TEXCOORD attribute used for texture coordinate mapping.
    Nullable!int texCoord;
    // The scalar multiplier applied to each normal vector of the normal texture.
    Nullable!float scale;
    // Dictionary object with extension-specific objects.
    MaterialNormalTextureInfoExtension extensions;
    // Application-specific data.
    MaterialNormalTextureInfoExtras extras;

    static MaterialNormalTextureInfo fromJSON(JSONValue src)
    {
        auto value = new MaterialNormalTextureInfo();
        if(const(JSONValue)* x = "index" in src){ value.index = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "texCoord" in src){ value.texCoord = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "scale" in src){ value.scale = nullable(x.asFloat); }
        // not implemented: MaterialNormalTextureInfoExtension
        // not implemented: MaterialNormalTextureInfoExtras
        return value;
    }
}

class MaterialOcclusionTextureInfoExtension
{

    static MaterialOcclusionTextureInfoExtension fromJSON(JSONValue src)
    {
        auto value = new MaterialOcclusionTextureInfoExtension();
        return value;
    }
}

class MaterialOcclusionTextureInfoExtras
{

    static MaterialOcclusionTextureInfoExtras fromJSON(JSONValue src)
    {
        auto value = new MaterialOcclusionTextureInfoExtras();
        return value;
    }
}

class MaterialOcclusionTextureInfo
{
    // The index of the bufferView.
    Nullable!int index;
    // The set index of texture's TEXCOORD attribute used for texture coordinate mapping.
    Nullable!int texCoord;
    // A scalar multiplier controlling the amount of occlusion applied.
    Nullable!float strength;
    // Dictionary object with extension-specific objects.
    MaterialOcclusionTextureInfoExtension extensions;
    // Application-specific data.
    MaterialOcclusionTextureInfoExtras extras;

    static MaterialOcclusionTextureInfo fromJSON(JSONValue src)
    {
        auto value = new MaterialOcclusionTextureInfo();
        if(const(JSONValue)* x = "index" in src){ value.index = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "texCoord" in src){ value.texCoord = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "strength" in src){ value.strength = nullable(x.asFloat); }
        // not implemented: MaterialOcclusionTextureInfoExtension
        // not implemented: MaterialOcclusionTextureInfoExtras
        return value;
    }
}

enum MaterialAlphaMode
{
    OPAQUE = "OPAQUE",
    MASK = "MASK",
    BLEND = "BLEND",
}

class Material
{
    // The user-defined name of this object.
    string name;
    // Dictionary object with extension-specific objects.
    MaterialExtension extensions;
    // Application-specific data.
    MaterialExtras extras;
    // A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology.
    MaterialPBRMetallicRoughness pbrMetallicRoughness;
    // Reference to a texture.
    MaterialNormalTextureInfo normalTexture;
    // Reference to a texture.
    MaterialOcclusionTextureInfo occlusionTexture;
    // Reference to a texture.
    TextureInfo emissiveTexture;
    // The emissive color of the material.
    float[] emissiveFactor;
    // The alpha rendering mode of the material.
    MaterialAlphaMode alphaMode;
    // The alpha cutoff value of the material.
    Nullable!float alphaCutoff;
    // Specifies whether the material is double sided.
    Nullable!bool doubleSided;

    static Material fromJSON(JSONValue src)
    {
        auto value = new Material();
        if(const(JSONValue)* x = "name" in src){ value.name = x.str; }
        // not implemented: MaterialExtension
        // not implemented: MaterialExtras
        if(const(JSONValue)* x = "pbrMetallicRoughness" in src){ value.pbrMetallicRoughness = MaterialPBRMetallicRoughness.fromJSON(src["pbrMetallicRoughness"]); }
        if(const(JSONValue)* x = "normalTexture" in src){ value.normalTexture = MaterialNormalTextureInfo.fromJSON(src["normalTexture"]); }
        if(const(JSONValue)* x = "occlusionTexture" in src){ value.occlusionTexture = MaterialOcclusionTextureInfo.fromJSON(src["occlusionTexture"]); }
        if(const(JSONValue)* x = "emissiveTexture" in src){ value.emissiveTexture = TextureInfo.fromJSON(src["emissiveTexture"]); }
        if(const(JSONValue)* x = "emissiveFactor" in src){ value.emissiveFactor = x.array.map!(a => a.asFloat).array; }
        if(const(JSONValue)* x = "alphaMode" in src){ value.alphaMode = to!MaterialAlphaMode(x.str); }
        if(const(JSONValue)* x = "alphaCutoff" in src){ value.alphaCutoff = nullable(x.asFloat); }
        if(const(JSONValue)* x = "doubleSided" in src){ value.doubleSided = x.boolean; }
        return value;
    }
}

enum MeshPrimitiveMode
{
    POINTS = 0,
    LINES = 1,
    LINE_LOOP = 2,
    LINE_STRIP = 3,
    TRIANGLES = 4,
    TRIANGLE_STRIP = 5,
    TRIANGLE_FAN = 6,
}

class MeshPrimitiveExtension
{

    static MeshPrimitiveExtension fromJSON(JSONValue src)
    {
        auto value = new MeshPrimitiveExtension();
        return value;
    }
}

class MeshPrimitiveExtras
{

    static MeshPrimitiveExtras fromJSON(JSONValue src)
    {
        auto value = new MeshPrimitiveExtras();
        return value;
    }
}

class MeshPrimitive
{
    // A dictionary object, where each key corresponds to mesh attribute semantic and each value is the index of the accessor containing attribute's data.
    int[string] attributes;
    // The index of the bufferView.
    Nullable!int indices;
    // The index of the bufferView.
    Nullable!int material;
    // The type of primitives to render.
    MeshPrimitiveMode mode;
    // An array of Morph Targets, each  Morph Target is a dictionary mapping attributes (only `POSITION`, `NORMAL`, and `TANGENT` supported) to their deviations in the Morph Target.
    int[string][] targets;
    // Dictionary object with extension-specific objects.
    MeshPrimitiveExtension extensions;
    // Application-specific data.
    MeshPrimitiveExtras extras;

    static MeshPrimitive fromJSON(JSONValue src)
    {
        auto value = new MeshPrimitive();
        if(const(JSONValue)* x = "attributes" in src){ value.attributes = x.object.byPair.map!(kv => tuple(kv.key, cast(int)kv.value.integer)).assocArray; }
        if(const(JSONValue)* x = "indices" in src){ value.indices = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "material" in src){ value.material = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "mode" in src){ value.mode = cast(MeshPrimitiveMode)x.integer; }
        if(const(JSONValue)* x = "targets" in src){ value.targets = x.array.map!(a => a.object.byPair.map!(kv => tuple(kv.key, cast(int)kv.value.integer)).assocArray).array; }
        // not implemented: MeshPrimitiveExtension
        // not implemented: MeshPrimitiveExtras
        return value;
    }
}

class MeshExtension
{

    static MeshExtension fromJSON(JSONValue src)
    {
        auto value = new MeshExtension();
        return value;
    }
}

class MeshExtras
{

    static MeshExtras fromJSON(JSONValue src)
    {
        auto value = new MeshExtras();
        return value;
    }
}

class Mesh
{
    // An array of primitives, each defining geometry to be rendered with a material.
    MeshPrimitive[] primitives;
    // Array of weights to be applied to the Morph Targets.
    float[] weights;
    // The user-defined name of this object.
    string name;
    // Dictionary object with extension-specific objects.
    MeshExtension extensions;
    // Application-specific data.
    MeshExtras extras;

    static Mesh fromJSON(JSONValue src)
    {
        auto value = new Mesh();
        if(const(JSONValue)* x = "primitives" in src){ value.primitives = x.array.map!(a => MeshPrimitive.fromJSON(a)).array; }
        if(const(JSONValue)* x = "weights" in src){ value.weights = x.array.map!(a => a.asFloat).array; }
        if(const(JSONValue)* x = "name" in src){ value.name = x.str; }
        // not implemented: MeshExtension
        // not implemented: MeshExtras
        return value;
    }
}

class NodeExtension
{

    static NodeExtension fromJSON(JSONValue src)
    {
        auto value = new NodeExtension();
        return value;
    }
}

class NodeExtras
{

    static NodeExtras fromJSON(JSONValue src)
    {
        auto value = new NodeExtras();
        return value;
    }
}

class Node
{
    // The index of the bufferView.
    Nullable!int camera;
    // The indices of this node's children.
    int[] children;
    // The index of the bufferView.
    Nullable!int skin;
    // A floating-point 4x4 transformation matrix stored in column-major order.
    float[] matrix;
    // The index of the bufferView.
    Nullable!int mesh;
    // The node's unit quaternion rotation in the order (x, y, z, w), where w is the scalar.
    float[] rotation;
    // The node's non-uniform scale, given as the scaling factors along the x, y, and z axes.
    float[] scale;
    // The node's translation along the x, y, and z axes.
    float[] translation;
    // The weights of the instantiated Morph Target. Number of elements must match number of Morph Targets of used mesh.
    float[] weights;
    // The user-defined name of this object.
    string name;
    // Dictionary object with extension-specific objects.
    NodeExtension extensions;
    // Application-specific data.
    NodeExtras extras;

    static Node fromJSON(JSONValue src)
    {
        auto value = new Node();
        if(const(JSONValue)* x = "camera" in src){ value.camera = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "children" in src){ value.children = x.array.map!(a => cast(int)a.integer).array; }
        if(const(JSONValue)* x = "skin" in src){ value.skin = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "matrix" in src){ value.matrix = x.array.map!(a => a.asFloat).array; }
        if(const(JSONValue)* x = "mesh" in src){ value.mesh = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "rotation" in src){ value.rotation = x.array.map!(a => a.asFloat).array; }
        if(const(JSONValue)* x = "scale" in src){ value.scale = x.array.map!(a => a.asFloat).array; }
        if(const(JSONValue)* x = "translation" in src){ value.translation = x.array.map!(a => a.asFloat).array; }
        if(const(JSONValue)* x = "weights" in src){ value.weights = x.array.map!(a => a.asFloat).array; }
        if(const(JSONValue)* x = "name" in src){ value.name = x.str; }
        // not implemented: NodeExtension
        // not implemented: NodeExtras
        return value;
    }
}

enum SamplerMagFilter
{
    NEAREST = 9728,
    LINEAR = 9729,
}

enum SamplerMinFilter
{
    NEAREST = 9728,
    LINEAR = 9729,
    NEAREST_MIPMAP_NEAREST = 9984,
    LINEAR_MIPMAP_NEAREST = 9985,
    NEAREST_MIPMAP_LINEAR = 9986,
    LINEAR_MIPMAP_LINEAR = 9987,
}

enum SamplerWrapS
{
    CLAMP_TO_EDGE = 33071,
    MIRRORED_REPEAT = 33648,
    REPEAT = 10497,
}

enum SamplerWrapT
{
    CLAMP_TO_EDGE = 33071,
    MIRRORED_REPEAT = 33648,
    REPEAT = 10497,
}

class SamplerExtension
{

    static SamplerExtension fromJSON(JSONValue src)
    {
        auto value = new SamplerExtension();
        return value;
    }
}

class SamplerExtras
{

    static SamplerExtras fromJSON(JSONValue src)
    {
        auto value = new SamplerExtras();
        return value;
    }
}

class Sampler
{
    // Magnification filter.
    SamplerMagFilter magFilter;
    // Minification filter.
    SamplerMinFilter minFilter;
    // s wrapping mode.
    SamplerWrapS wrapS;
    // t wrapping mode.
    SamplerWrapT wrapT;
    // The user-defined name of this object.
    string name;
    // Dictionary object with extension-specific objects.
    SamplerExtension extensions;
    // Application-specific data.
    SamplerExtras extras;

    static Sampler fromJSON(JSONValue src)
    {
        auto value = new Sampler();
        if(const(JSONValue)* x = "magFilter" in src){ value.magFilter = cast(SamplerMagFilter)x.integer; }
        if(const(JSONValue)* x = "minFilter" in src){ value.minFilter = cast(SamplerMinFilter)x.integer; }
        if(const(JSONValue)* x = "wrapS" in src){ value.wrapS = cast(SamplerWrapS)x.integer; }
        if(const(JSONValue)* x = "wrapT" in src){ value.wrapT = cast(SamplerWrapT)x.integer; }
        if(const(JSONValue)* x = "name" in src){ value.name = x.str; }
        // not implemented: SamplerExtension
        // not implemented: SamplerExtras
        return value;
    }
}

class SceneExtension
{

    static SceneExtension fromJSON(JSONValue src)
    {
        auto value = new SceneExtension();
        return value;
    }
}

class SceneExtras
{

    static SceneExtras fromJSON(JSONValue src)
    {
        auto value = new SceneExtras();
        return value;
    }
}

class Scene
{
    // The indices of each root node.
    int[] nodes;
    // The user-defined name of this object.
    string name;
    // Dictionary object with extension-specific objects.
    SceneExtension extensions;
    // Application-specific data.
    SceneExtras extras;

    static Scene fromJSON(JSONValue src)
    {
        auto value = new Scene();
        if(const(JSONValue)* x = "nodes" in src){ value.nodes = x.array.map!(a => cast(int)a.integer).array; }
        if(const(JSONValue)* x = "name" in src){ value.name = x.str; }
        // not implemented: SceneExtension
        // not implemented: SceneExtras
        return value;
    }
}

class SkinExtension
{

    static SkinExtension fromJSON(JSONValue src)
    {
        auto value = new SkinExtension();
        return value;
    }
}

class SkinExtras
{

    static SkinExtras fromJSON(JSONValue src)
    {
        auto value = new SkinExtras();
        return value;
    }
}

class Skin
{
    // The index of the bufferView.
    Nullable!int inverseBindMatrices;
    // The index of the bufferView.
    Nullable!int skeleton;
    // Indices of skeleton nodes, used as joints in this skin.
    int[] joints;
    // The user-defined name of this object.
    string name;
    // Dictionary object with extension-specific objects.
    SkinExtension extensions;
    // Application-specific data.
    SkinExtras extras;

    static Skin fromJSON(JSONValue src)
    {
        auto value = new Skin();
        if(const(JSONValue)* x = "inverseBindMatrices" in src){ value.inverseBindMatrices = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "skeleton" in src){ value.skeleton = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "joints" in src){ value.joints = x.array.map!(a => cast(int)a.integer).array; }
        if(const(JSONValue)* x = "name" in src){ value.name = x.str; }
        // not implemented: SkinExtension
        // not implemented: SkinExtras
        return value;
    }
}

class TextureExtension
{

    static TextureExtension fromJSON(JSONValue src)
    {
        auto value = new TextureExtension();
        return value;
    }
}

class TextureExtras
{

    static TextureExtras fromJSON(JSONValue src)
    {
        auto value = new TextureExtras();
        return value;
    }
}

class Texture
{
    // The index of the bufferView.
    Nullable!int sampler;
    // The index of the bufferView.
    Nullable!int source;
    // The user-defined name of this object.
    string name;
    // Dictionary object with extension-specific objects.
    TextureExtension extensions;
    // Application-specific data.
    TextureExtras extras;

    static Texture fromJSON(JSONValue src)
    {
        auto value = new Texture();
        if(const(JSONValue)* x = "sampler" in src){ value.sampler = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "source" in src){ value.source = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "name" in src){ value.name = x.str; }
        // not implemented: TextureExtension
        // not implemented: TextureExtras
        return value;
    }
}

class glTFExtension
{

    static glTFExtension fromJSON(JSONValue src)
    {
        auto value = new glTFExtension();
        return value;
    }
}

class glTFExtras
{

    static glTFExtras fromJSON(JSONValue src)
    {
        auto value = new glTFExtras();
        return value;
    }
}

class glTF
{
    // Names of glTF extensions used somewhere in this asset.
    string[] extensionsUsed;
    // Names of glTF extensions required to properly load this asset.
    string[] extensionsRequired;
    // An array of accessors.
    Accessor[] accessors;
    // An array of keyframe animations.
    Animation[] animations;
    // Metadata about the glTF asset.
    Asset asset;
    // An array of buffers.
    Buffer[] buffers;
    // An array of bufferViews.
    BufferView[] bufferViews;
    // An array of cameras.
    Camera[] cameras;
    // An array of images.
    Image[] images;
    // An array of materials.
    Material[] materials;
    // An array of meshes.
    Mesh[] meshes;
    // An array of nodes.
    Node[] nodes;
    // An array of samplers.
    Sampler[] samplers;
    // The index of the bufferView.
    Nullable!int scene;
    // An array of scenes.
    Scene[] scenes;
    // An array of skins.
    Skin[] skins;
    // An array of textures.
    Texture[] textures;
    // Dictionary object with extension-specific objects.
    glTFExtension extensions;
    // Application-specific data.
    glTFExtras extras;

    static glTF fromJSON(JSONValue src)
    {
        auto value = new glTF();
        if(const(JSONValue)* x = "extensionsUsed" in src){ value.extensionsUsed = x.array.map!(a => a.str).array; }
        if(const(JSONValue)* x = "extensionsRequired" in src){ value.extensionsRequired = x.array.map!(a => a.str).array; }
        if(const(JSONValue)* x = "accessors" in src){ value.accessors = x.array.map!(a => Accessor.fromJSON(a)).array; }
        if(const(JSONValue)* x = "animations" in src){ value.animations = x.array.map!(a => Animation.fromJSON(a)).array; }
        if(const(JSONValue)* x = "asset" in src){ value.asset = Asset.fromJSON(src["asset"]); }
        if(const(JSONValue)* x = "buffers" in src){ value.buffers = x.array.map!(a => Buffer.fromJSON(a)).array; }
        if(const(JSONValue)* x = "bufferViews" in src){ value.bufferViews = x.array.map!(a => BufferView.fromJSON(a)).array; }
        if(const(JSONValue)* x = "cameras" in src){ value.cameras = x.array.map!(a => Camera.fromJSON(a)).array; }
        if(const(JSONValue)* x = "images" in src){ value.images = x.array.map!(a => Image.fromJSON(a)).array; }
        if(const(JSONValue)* x = "materials" in src){ value.materials = x.array.map!(a => Material.fromJSON(a)).array; }
        if(const(JSONValue)* x = "meshes" in src){ value.meshes = x.array.map!(a => Mesh.fromJSON(a)).array; }
        if(const(JSONValue)* x = "nodes" in src){ value.nodes = x.array.map!(a => Node.fromJSON(a)).array; }
        if(const(JSONValue)* x = "samplers" in src){ value.samplers = x.array.map!(a => Sampler.fromJSON(a)).array; }
        if(const(JSONValue)* x = "scene" in src){ value.scene = nullable(cast(int)x.integer); }
        if(const(JSONValue)* x = "scenes" in src){ value.scenes = x.array.map!(a => Scene.fromJSON(a)).array; }
        if(const(JSONValue)* x = "skins" in src){ value.skins = x.array.map!(a => Skin.fromJSON(a)).array; }
        if(const(JSONValue)* x = "textures" in src){ value.textures = x.array.map!(a => Texture.fromJSON(a)).array; }
        // not implemented: glTFExtension
        // not implemented: glTFExtras
        return value;
    }
}
